<?php
/**
 * Migrator class
 *
 * @package WPSiteBridge
 */

namespace WPSiteBridge;

// Exit if accessed directly
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Migrator class
 */
class Migrator {
	
	/**
	 * Plugin instance
	 *
	 * @var Migrator
	 */
	private static $instance = null;
	
	/**
	 * Get plugin instance
	 *
	 * @return Migrator
	 */
	public static function get_instance() {
		if ( null === self::$instance ) {
			self::$instance = new self();
		}
		return self::$instance;
	}
	
	/**
	 * Constructor
	 */
	private function __construct() {
		// Migration logic will be implemented in Phase 3, 4, and 5
	}
	
	/**
	 * Get or create temporary directory
	 *
	 * Creates wp-content/uploads/wpsbm_temp/ if it doesn't exist
	 * Adds .htaccess for protection
	 *
	 * @return string|false Path to temp directory, or false on failure
	 */
	public function get_temp_dir() {
		$upload_dir = wp_upload_dir();
		
		if ( $upload_dir['error'] ) {
			return false;
		}
		
		$temp_dir = trailingslashit( $upload_dir['basedir'] ) . 'wpsbm_temp';
		
		// Create directory if it doesn't exist
		if ( ! file_exists( $temp_dir ) ) {
			wp_mkdir_p( $temp_dir );
		}
		
		// Check if directory was created successfully
		if ( ! is_dir( $temp_dir ) || ! is_writable( $temp_dir ) ) {
			return false;
		}
		
		// Add .htaccess for protection
		$htaccess_file = trailingslashit( $temp_dir ) . '.htaccess';
		if ( ! file_exists( $htaccess_file ) ) {
			file_put_contents( $htaccess_file, "deny from all\n" );
		}
		
		// Add index.php to prevent directory listing
		$index_file = trailingslashit( $temp_dir ) . 'index.php';
		if ( ! file_exists( $index_file ) ) {
			file_put_contents( $index_file, "<?php\n// Silence is golden.\n" );
		}
		
		return $temp_dir;
	}
	
	/**
	 * Export database to SQL file
	 *
	 * Exports all tables with structure and data
	 * Uses chunking to avoid memory exhaustion
	 *
	 * @return array|false Array with 'file' and 'size' keys, or false on failure
	 */
	public function export_database() {
		global $wpdb;
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		$sql_file = trailingslashit( $temp_dir ) . 'database.sql';
		
		// Open file for writing
		$handle = fopen( $sql_file, 'w' );
		if ( false === $handle ) {
			return false;
		}
		
		// Write SQL header
		fwrite( $handle, "-- WordPress Database Backup\n" );
		fwrite( $handle, "-- Generated by WP Site Bridge Migration\n" );
		fwrite( $handle, "-- Date: " . current_time( 'mysql' ) . "\n\n" );
		fwrite( $handle, "SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\n" );
		fwrite( $handle, "SET time_zone = \"+00:00\";\n\n" );
		
		// Get all tables
		$tables = $wpdb->get_results( 'SHOW TABLES', ARRAY_N );
		
		if ( empty( $tables ) ) {
			fclose( $handle );
			return false;
		}
		
		// Process each table
		foreach ( $tables as $table ) {
			$table_name = $table[0];
			
			// Sanitize table name (remove any potential backticks first, then add our own)
			$table_name_clean = str_replace( '`', '', $table_name );
			
			// Skip if table doesn't exist
			if ( ! $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table_name_clean ) ) ) {
				continue;
			}
			
			// Write table comment
			fwrite( $handle, "\n--\n" );
			fwrite( $handle, "-- Table structure for table `{$table_name_clean}`\n" );
			fwrite( $handle, "--\n\n" );
			
			// Get table structure
			$create_table = $wpdb->get_row( "SHOW CREATE TABLE `{$table_name_clean}`", ARRAY_A );
			
			if ( isset( $create_table['Create Table'] ) ) {
				// Write DROP TABLE and CREATE TABLE
				fwrite( $handle, "DROP TABLE IF EXISTS `{$table_name_clean}`;\n" );
				fwrite( $handle, $create_table['Create Table'] . ";\n\n" );
			}
			
			// Get row count
			$row_count = $wpdb->get_var( "SELECT COUNT(*) FROM `{$table_name_clean}`" );
			
			if ( 0 === (int) $row_count ) {
				// Empty table, skip data
				continue;
			}
			
			// Write data comment
			fwrite( $handle, "--\n" );
			fwrite( $handle, "-- Dumping data for table `{$table_name_clean}`\n" );
			fwrite( $handle, "--\n\n" );
			
			// Get table columns
			$columns = $wpdb->get_col( "SHOW COLUMNS FROM `{$table_name_clean}`" );
			
			if ( empty( $columns ) ) {
				continue;
			}
			
			// Process data in chunks (1000 rows at a time)
			$chunk_size = 1000;
			$offset = 0;
			
			while ( true ) {
				// Get chunk of data
				$rows = $wpdb->get_results(
					$wpdb->prepare(
						"SELECT * FROM `{$table_name_clean}` LIMIT %d OFFSET %d",
						$chunk_size,
						$offset
					),
					ARRAY_A
				);
				
				if ( empty( $rows ) ) {
					break;
				}
				
				// Write INSERT statements
				foreach ( $rows as $row ) {
					// Build column names
					$column_names = '`' . implode( '`, `', $columns ) . '`';
					
					// Build values
					$values = array();
					foreach ( $columns as $column ) {
						$value = isset( $row[ $column ] ) ? $row[ $column ] : null;
						
						if ( null === $value ) {
							$values[] = 'NULL';
						} else {
							// Escape value properly
							// Use addslashes for basic escaping, then wrap in quotes
							$escaped = addslashes( $value );
							// Replace newlines and carriage returns
							$escaped = str_replace( array( "\r", "\n" ), array( '\\r', '\\n' ), $escaped );
							$values[] = "'" . $escaped . "'";
						}
					}
					
					$values_string = implode( ', ', $values );
					
					// Write INSERT statement
					fwrite( $handle, "INSERT INTO `{$table_name_clean}` ({$column_names}) VALUES ({$values_string});\n" );
				}
				
				$offset += $chunk_size;
				
				// Check if we've processed all rows
				if ( count( $rows ) < $chunk_size ) {
					break;
				}
				
				// Free memory
				unset( $rows );
			}
			
			fwrite( $handle, "\n" );
		}
		
		// Close file
		fclose( $handle );
		
		// Check if file was created successfully
		if ( ! file_exists( $sql_file ) ) {
			return false;
		}
		
		// Get file size
		$file_size = filesize( $sql_file );
		
		return array(
			'file' => 'database.sql',
			'path' => $sql_file,
			'size' => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Zip a directory
	 *
	 * Creates a zip archive of a directory with exclusions
	 *
	 * @param string $source_dir Source directory to zip
	 * @param string $zip_name Name of the zip file (without path)
	 * @return array|false Array with 'file', 'path', 'size', 'size_formatted' or false on failure
	 */
	public function zip_directory( $source_dir, $zip_name ) {
		// Check if ZipArchive is available
		if ( ! class_exists( 'ZipArchive' ) ) {
			return false;
		}
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		// Check if source directory exists
		if ( ! is_dir( $source_dir ) ) {
			return false;
		}
		
		// Full path to zip file
		$zip_path = trailingslashit( $temp_dir ) . $zip_name;
		
		// Remove existing zip if it exists
		if ( file_exists( $zip_path ) ) {
			@unlink( $zip_path );
		}
		
		// Create new zip archive
		$zip = new \ZipArchive();
		$result = $zip->open( $zip_path, \ZipArchive::CREATE | \ZipArchive::OVERWRITE );
		
		if ( true !== $result ) {
			return false;
		}
		
		// Define exclusions
		$exclusions = array(
			'node_modules',
			'.git',
			'cache',
			'wpsbm_temp',
			'error_log',
			'.DS_Store',
			'Thumbs.db',
		);
		
		// Recursively add files to zip
		$this->add_directory_to_zip( $zip, $source_dir, $source_dir, $exclusions );
		
		// Close zip
		$zip->close();
		
		// Check if file was created
		if ( ! file_exists( $zip_path ) ) {
			return false;
		}
		
		// Get file size
		$file_size = filesize( $zip_path );
		
		return array(
			'file'          => $zip_name,
			'path'          => $zip_path,
			'size'          => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Recursively add directory to zip
	 *
	 * @param ZipArchive $zip ZipArchive instance
	 * @param string $dir Directory to add
	 * @param string $base_dir Base directory for relative paths
	 * @param array $exclusions Array of excluded directory/file names
	 */
	private function add_directory_to_zip( $zip, $dir, $base_dir, $exclusions ) {
		$files = scandir( $dir );
		
		foreach ( $files as $file ) {
			if ( '.' === $file || '..' === $file ) {
				continue;
			}
			
			$file_path = trailingslashit( $dir ) . $file;
			$relative_path = str_replace( trailingslashit( $base_dir ), '', $file_path );
			
			// Check if file/directory should be excluded
			if ( $this->should_exclude( $file, $file_path, $exclusions ) ) {
				continue;
			}
			
			if ( is_dir( $file_path ) ) {
				// Recursively add directory
				$this->add_directory_to_zip( $zip, $file_path, $base_dir, $exclusions );
			} else {
				// Add file to zip
				$zip->addFile( $file_path, $relative_path );
			}
		}
	}
	
	/**
	 * Check if file/directory should be excluded
	 *
	 * @param string $name File/directory name
	 * @param string $path Full path
	 * @param array $exclusions Array of exclusions
	 * @return bool True if should be excluded
	 */
	private function should_exclude( $name, $path, $exclusions ) {
		// Check exact name match
		if ( in_array( $name, $exclusions, true ) ) {
			return true;
		}
		
		// Check if path contains excluded directory
		foreach ( $exclusions as $exclusion ) {
			if ( false !== strpos( $path, '/' . $exclusion . '/' ) || false !== strpos( $path, '\\' . $exclusion . '\\' ) ) {
				return true;
			}
		}
		
		// Exclude hidden files (starting with .)
		if ( '.' === substr( $name, 0, 1 ) && '.htaccess' !== $name && 'index.php' !== $name ) {
			return true;
		}
		
		return false;
	}
	
	/**
	 * Zip plugins directory
	 *
	 * @return array|false Array with file info or false on failure
	 */
	public function zip_plugins() {
		$plugins_dir = WP_PLUGIN_DIR;
		return $this->zip_directory( $plugins_dir, 'plugins.zip' );
	}
	
	/**
	 * Zip themes directory
	 *
	 * @return array|false Array with file info or false on failure
	 */
	public function zip_themes() {
		$themes_dir = trailingslashit( WP_CONTENT_DIR ) . 'themes';
		return $this->zip_directory( $themes_dir, 'themes.zip' );
	}
	
	/**
	 * Zip uploads directory
	 *
	 * @return array|false Array with file info or false on failure
	 */
	public function zip_uploads() {
		$upload_dir = wp_upload_dir();
		if ( $upload_dir['error'] ) {
			return false;
		}
		
		$uploads_dir = $upload_dir['basedir'];
		
		// Exclude wpsbm_temp from uploads
		$exclusions = array( 'wpsbm_temp' );
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		// Check if ZipArchive is available
		if ( ! class_exists( 'ZipArchive' ) ) {
			return false;
		}
		
		// Check if source directory exists
		if ( ! is_dir( $uploads_dir ) ) {
			return false;
		}
		
		// Full path to zip file
		$zip_path = trailingslashit( $temp_dir ) . 'uploads.zip';
		
		// Remove existing zip if it exists
		if ( file_exists( $zip_path ) ) {
			@unlink( $zip_path );
		}
		
		// Create new zip archive
		$zip = new \ZipArchive();
		$result = $zip->open( $zip_path, \ZipArchive::CREATE | \ZipArchive::OVERWRITE );
		
		if ( true !== $result ) {
			return false;
		}
		
		// Define exclusions (merge with default)
		$all_exclusions = array_merge(
			array(
				'node_modules',
				'.git',
				'cache',
				'error_log',
				'.DS_Store',
				'Thumbs.db',
			),
			$exclusions
		);
		
		// Recursively add files to zip
		$this->add_directory_to_zip( $zip, $uploads_dir, $uploads_dir, $all_exclusions );
		
		// Close zip
		$zip->close();
		
		// Check if file was created
		if ( ! file_exists( $zip_path ) ) {
			return false;
		}
		
		// Get file size
		$file_size = filesize( $zip_path );
		
		return array(
			'file'          => 'uploads.zip',
			'path'          => $zip_path,
			'size'          => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Generate migration key
	 *
	 * Generates a secure random token and creates a migration key
	 * in the format: base64_encode(SITE_URL + '||' + SECRET_TOKEN)
	 *
	 * @return string Migration key
	 */
	public function generate_migration_key() {
		// Generate a secure random token (32 characters)
		$token = $this->generate_secure_token( 32 );
		
		// Save token to wp_options
		update_option( 'wpsbm_secret_token', $token );
		
		// Get site URL
		$site_url = trailingslashit( get_site_url() );
		
		// Construct migration key: base64_encode(SITE_URL + '||' + SECRET_TOKEN)
		$key_data = $site_url . '||' . $token;
		$migration_key = base64_encode( $key_data );
		
		// Also save the full migration key for reference
		update_option( 'wpsbm_migration_key', $migration_key );
		
		return $migration_key;
	}
	
	/**
	 * Generate secure random token
	 *
	 * @param int $length Token length
	 * @return string Random token
	 */
	public function generate_secure_token( $length = 32 ) {
		// Use cryptographically secure random bytes
		if ( function_exists( 'random_bytes' ) ) {
			$bytes = random_bytes( $length );
			return bin2hex( $bytes );
		} elseif ( function_exists( 'openssl_random_pseudo_bytes' ) ) {
			$bytes = openssl_random_pseudo_bytes( $length );
			return bin2hex( $bytes );
		} else {
			// Fallback (less secure but still random)
			$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
			$token = '';
			for ( $i = 0; $i < $length; $i++ ) {
				$token .= $chars[ wp_rand( 0, strlen( $chars ) - 1 ) ];
			}
			return $token;
		}
	}
	
	/**
	 * Verify token
	 *
	 * Check if the received token matches the stored token
	 *
	 * @param string $token Token to verify
	 * @return bool True if token is valid, false otherwise
	 */
	public function verify_token( $token ) {
		if ( empty( $token ) ) {
			return false;
		}
		
		// Get stored token
		$stored_token = get_option( 'wpsbm_secret_token' );
		
		if ( empty( $stored_token ) ) {
			return false;
		}
		
		// Use hash_equals for timing-safe comparison
		return hash_equals( $stored_token, $token );
	}
	
	/**
	 * Parse migration key
	 *
	 * Decodes a migration key and extracts site URL and token
	 *
	 * @param string $migration_key Migration key to parse
	 * @return array|false Array with 'url' and 'token' keys, or false on failure
	 */
	public function parse_migration_key( $migration_key ) {
		if ( empty( $migration_key ) ) {
			return false;
		}
		
		// Decode base64
		$decoded = base64_decode( $migration_key, true );
		
		if ( false === $decoded ) {
			return false;
		}
		
		// Split by delimiter
		$parts = explode( '||', $decoded, 2 );
		
		if ( count( $parts ) !== 2 ) {
			return false;
		}
		
		return array(
			'url'   => sanitize_url( $parts[0] ),
			'token' => sanitize_text_field( $parts[1] ),
		);
	}
	
	/**
	 * Download remote file
	 *
	 * Downloads a file from remote URL and saves it locally
	 *
	 * @param string $url Remote URL to download from
	 * @param string $save_path Local path to save the file
	 * @return array|false Array with 'path' and 'size' on success, false on failure
	 */
	public function download_remote_file( $url, $save_path ) {
		if ( empty( $url ) || empty( $save_path ) ) {
			return false;
		}
		
		// Ensure directory exists
		$save_dir = dirname( $save_path );
		if ( ! file_exists( $save_dir ) ) {
			wp_mkdir_p( $save_dir );
		}
		
		// Check if directory is writable
		if ( ! is_writable( $save_dir ) ) {
			return false;
		}
		
		// Use WordPress download_url function if available
		if ( function_exists( 'download_url' ) ) {
			$temp_file = download_url( $url );
			
			if ( is_wp_error( $temp_file ) ) {
				return false;
			}
			
			// Move temp file to final location
			if ( ! @rename( $temp_file, $save_path ) ) {
				@unlink( $temp_file );
				return false;
			}
			
			// Verify file was created
			if ( ! file_exists( $save_path ) ) {
				return false;
			}
			
			$file_size = filesize( $save_path );
			
			return array(
				'path'          => $save_path,
				'size'          => $file_size,
				'size_formatted' => size_format( $file_size, 2 ),
			);
		}
		
		// Fallback: Use wp_remote_get and write to file
		$response = wp_remote_get(
			$url,
			array(
				'timeout'   => 300, // 5 minutes
				'sslverify' => true,
			)
		);
		
		if ( is_wp_error( $response ) ) {
			return false;
		}
		
		$response_code = wp_remote_retrieve_response_code( $response );
		
		if ( 200 !== $response_code ) {
			return false;
		}
		
		// Get response body
		$body = wp_remote_retrieve_body( $response );
		
		if ( empty( $body ) ) {
			return false;
		}
		
		// Write to file
		$written = file_put_contents( $save_path, $body );
		
		if ( false === $written ) {
			return false;
		}
		
		// Verify file was created
		if ( ! file_exists( $save_path ) ) {
			return false;
		}
		
		$file_size = filesize( $save_path );
		
		return array(
			'path'          => $save_path,
			'size'          => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Download file from source site
	 *
	 * Downloads a specific file type from the source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @param string $file_type File type (database, plugins, themes, uploads)
	 * @return array|false Array with file info on success, false on failure
	 */
	public function download_from_source( $source_url, $token, $file_type ) {
		if ( empty( $source_url ) || empty( $token ) || empty( $file_type ) ) {
			return false;
		}
		
		// Validate file type
		if ( ! in_array( $file_type, array( 'database', 'plugins', 'themes', 'uploads' ), true ) ) {
			return false;
		}
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		// Map file type to filename
		$file_map = array(
			'database' => 'database.sql',
			'plugins'  => 'plugins.zip',
			'themes'   => 'themes.zip',
			'uploads'  => 'uploads.zip',
		);
		
		$filename = $file_map[ $file_type ];
		$save_path = trailingslashit( $temp_dir ) . $filename;
		
		// Build download URL
		$source_url = trailingslashit( $source_url );
		$download_url = $source_url . 'wp-json/wpsbm/v1/download?file_type=' . urlencode( $file_type ) . '&token=' . urlencode( $token );
		
		// Download file
		$result = $this->download_remote_file( $download_url, $save_path );
		
		if ( false === $result ) {
			return false;
		}
		
		return array(
			'file'          => $filename,
			'path'          => $result['path'],
			'size'          => $result['size'],
			'size_formatted' => $result['size_formatted'],
			'type'          => $file_type,
		);
	}
	
	/**
	 * Restore database from SQL file
	 *
	 * Downloads and imports database from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_database( $source_url, $token ) {
		global $wpdb;
		
		// Download database file
		$result = $this->download_from_source( $source_url, $token, 'database' );
		
		if ( false === $result ) {
			return false;
		}
		
		$sql_file = $result['path'];
		
		// Read SQL file
		if ( ! file_exists( $sql_file ) || ! is_readable( $sql_file ) ) {
			return false;
		}
		
		// Use streaming parser for memory efficiency (handles large files)
		$queries = $this->split_sql_queries_streaming( $sql_file );
		
		if ( empty( $queries ) ) {
			return false;
		}
		
		// Disable foreign key checks temporarily
		$wpdb->query( 'SET FOREIGN_KEY_CHECKS=0;' );
		
		// Execute each query
		foreach ( $queries as $query ) {
			$query = trim( $query );
			
			// Skip empty queries and comments
			if ( empty( $query ) || '--' === substr( $query, 0, 2 ) ) {
				continue;
			}
			
			// Execute query
			$wpdb->query( $query );
			
			// Check for errors
			if ( ! empty( $wpdb->last_error ) ) {
				// Log error but continue (some queries might fail due to existing tables)
				error_log( 'WPSBM Database Import Error: ' . $wpdb->last_error );
			}
		}
		
		// Re-enable foreign key checks
		$wpdb->query( 'SET FOREIGN_KEY_CHECKS=1;' );
		
		// Clean up SQL file
		@unlink( $sql_file );
		
		return true;
	}
	
	/**
	 * Split SQL content into individual queries (legacy method for small files)
	 *
	 * @param string $sql SQL content
	 * @return array Array of SQL queries
	 */
	private function split_sql_queries( $sql ) {
		// Remove SQL comments
		$sql = preg_replace( '/--.*$/m', '', $sql );
		$sql = preg_replace( '/\/\*.*?\*\//s', '', $sql );
		
		// Split by semicolon, but preserve semicolons inside quotes
		$queries = array();
		$current_query = '';
		$in_string = false;
		$string_char = '';
		
		for ( $i = 0; $i < strlen( $sql ); $i++ ) {
			$char = $sql[ $i ];
			
			if ( ! $in_string && ( "'" === $char || '"' === $char || '`' === $char ) ) {
				$in_string = true;
				$string_char = $char;
			} elseif ( $in_string && $char === $string_char && ( $i === 0 || $sql[ $i - 1 ] !== '\\' ) ) {
				$in_string = false;
				$string_char = '';
			}
			
			$current_query .= $char;
			
			if ( ! $in_string && ';' === $char ) {
				$queries[] = trim( $current_query );
				$current_query = '';
			}
		}
		
		// Add last query if exists
		if ( ! empty( trim( $current_query ) ) ) {
			$queries[] = trim( $current_query );
		}
		
		return array_filter( $queries );
	}
	
	/**
	 * Split SQL file into individual queries using streaming (memory efficient)
	 *
	 * Reads file in chunks to avoid loading entire file into memory.
	 * Handles escaped quotes, multi-byte characters, and queries that span chunks.
	 *
	 * @param string $sql_file Path to SQL file
	 * @return array Array of SQL queries
	 */
	private function split_sql_queries_streaming( $sql_file ) {
		$queries = array();
		$current_query = '';
		
		// State machine variables
		$in_string = false;
		$string_char = '';
		$in_comment_single = false; // -- comment
		$in_comment_multi = false;  // /* comment */
		$comment_start_pos = 0;
		
		// Open file handle
		$handle = fopen( $sql_file, 'r' );
		if ( false === $handle ) {
			return array();
		}
		
		// Read file in chunks (1MB at a time for optimal balance)
		$chunk_size = 1024 * 1024; // 1MB
		$buffer = '';
		$query_count = 0;
		
		while ( ! feof( $handle ) ) {
			$chunk = fread( $handle, $chunk_size );
			if ( false === $chunk ) {
				break;
			}
			
			$buffer .= $chunk;
			$buffer_length = strlen( $buffer );
			
			// Process buffer character by character
			$processed_length = 0;
			
			for ( $i = 0; $i < $buffer_length; $i++ ) {
				$char = $buffer[ $i ];
				$prev_char = ( $i > 0 ) ? $buffer[ $i - 1 ] : '';
				$next_char = ( $i < $buffer_length - 1 ) ? $buffer[ $i + 1 ] : '';
				
				// Handle multi-line comments /* ... */
				if ( ! $in_string && ! $in_comment_single && ! $in_comment_multi ) {
					if ( $char === '/' && $next_char === '*' ) {
						$in_comment_multi = true;
						$comment_start_pos = $i;
						$i++; // Skip next character
						continue;
					}
				}
				
				if ( $in_comment_multi ) {
					if ( $prev_char === '*' && $char === '/' ) {
						$in_comment_multi = false;
						continue; // Skip the closing */
					}
					continue; // Skip all characters inside multi-line comment
				}
				
				// Handle single-line comments --
				if ( ! $in_string && ! $in_comment_single && ! $in_comment_multi ) {
					if ( $char === '-' && $next_char === '-' ) {
						$in_comment_single = true;
						$i++; // Skip next character
						continue;
					}
				}
				
				if ( $in_comment_single ) {
					if ( $char === "\n" || $char === "\r" ) {
						$in_comment_single = false;
					}
					continue; // Skip all characters until newline
				}
				
				// Handle string detection (only when not in comments)
				if ( ! $in_string && ( "'" === $char || '"' === $char || '`' === $char ) ) {
					$in_string = true;
					$string_char = $char;
					$current_query .= $char;
					$processed_length = $i + 1;
					continue;
				}
				
				// Handle string closing
				if ( $in_string ) {
					// Check for escaped quote (backslash before quote)
					// But also handle double escape: \\' means literal backslash + quote
					$is_escaped = false;
					$escape_count = 0;
					
					// Count consecutive backslashes before current position
					for ( $j = $i - 1; $j >= 0 && $buffer[ $j ] === '\\'; $j-- ) {
						$escape_count++;
					}
					
					// If odd number of backslashes, the quote is escaped
					// If even number (including 0), the quote is not escaped
					$is_escaped = ( $escape_count % 2 === 1 );
					
					if ( $char === $string_char && ! $is_escaped ) {
						$in_string = false;
						$string_char = '';
						$current_query .= $char;
						$processed_length = $i + 1;
						continue;
					}
					
					// Still inside string, add character
					$current_query .= $char;
					$processed_length = $i + 1;
					continue;
				}
				
				// Not in string or comment, process normally
				$current_query .= $char;
				$processed_length = $i + 1;
				
				// Check for end of query (semicolon)
				if ( ';' === $char ) {
					$query = trim( $current_query );
					
					// Only add non-empty queries that aren't just comments
					if ( ! empty( $query ) && '--' !== substr( $query, 0, 2 ) ) {
						$queries[] = $query;
						$query_count++;
						
						// Free memory periodically (every 1000 queries)
						if ( $query_count % 1000 === 0 ) {
							gc_collect_cycles();
						}
					}
					
					$current_query = '';
				}
			}
			
			// Keep unprocessed part of buffer (in case query/string/comment spans chunks)
			// Strategy: Keep everything that's part of an incomplete state
			if ( $in_string || $in_comment_single || $in_comment_multi || ! empty( $current_query ) ) {
				// We need to keep the incomplete part for next chunk
				// The safest approach: keep current_query + any trailing characters
				// But we need to find where current_query starts in the buffer
				
				if ( ! empty( $current_query ) ) {
					// Find the position where current_query starts in buffer
					// Search backwards from end, looking for start of current_query
					$query_prefix = substr( $current_query, 0, min( 200, strlen( $current_query ) ) );
					$query_start_pos = strrpos( $buffer, $query_prefix );
					
					if ( false !== $query_start_pos ) {
						// Keep from query start to end of buffer
						$buffer = substr( $buffer, $query_start_pos );
					} else {
						// Fallback: if we can't find it, keep last 50KB (very safe)
						// This handles edge cases where query might have been modified
						$buffer = substr( $buffer, max( 0, $buffer_length - 51200 ) );
					}
				} elseif ( $in_comment_multi ) {
					// Keep from comment start
					$buffer = substr( $buffer, max( 0, $comment_start_pos ) );
				} elseif ( $in_comment_single ) {
					// Single-line comment: keep from last newline
					$last_newline = strrpos( $buffer, "\n" );
					if ( false !== $last_newline ) {
						$buffer = substr( $buffer, $last_newline + 1 );
					}
					// If no newline found, keep entire buffer (comment spans chunks)
				} elseif ( $in_string ) {
					// String spans chunks: find where string started
					// Look for the opening quote of current string
					$quote_pos = strrpos( $buffer, $string_char );
					if ( false !== $quote_pos ) {
						// Check if it's the opening quote (not escaped)
						$before_quote = ( $quote_pos > 0 ) ? $buffer[ $quote_pos - 1 ] : '';
						if ( $before_quote !== '\\' ) {
							$buffer = substr( $buffer, $quote_pos );
						} else {
							// Escaped quote, keep more context
							$buffer = substr( $buffer, max( 0, $quote_pos - 100 ) );
						}
					} else {
						// Can't find quote, keep last 10KB to be safe
						$buffer = substr( $buffer, max( 0, $buffer_length - 10240 ) );
					}
				}
			} else {
				// All processed, clear buffer
				$buffer = '';
			}
		}
		
		// Close file handle
		fclose( $handle );
		
		// Process remaining buffer
		if ( ! empty( $buffer ) ) {
			// Process remaining buffer with same logic
			$buffer_length = strlen( $buffer );
			for ( $i = 0; $i < $buffer_length; $i++ ) {
				$char = $buffer[ $i ];
				$prev_char = ( $i > 0 ) ? $buffer[ $i - 1 ] : '';
				
				// Handle comments (same logic as above)
				if ( ! $in_string && ! $in_comment_single && ! $in_comment_multi ) {
					if ( $char === '/' && isset( $buffer[ $i + 1 ] ) && $buffer[ $i + 1 ] === '*' ) {
						$in_comment_multi = true;
						$i++;
						continue;
					}
					if ( $char === '-' && isset( $buffer[ $i + 1 ] ) && $buffer[ $i + 1 ] === '-' ) {
						$in_comment_single = true;
						$i++;
						continue;
					}
				}
				
				if ( $in_comment_multi ) {
					if ( $prev_char === '*' && $char === '/' ) {
						$in_comment_multi = false;
					}
					continue;
				}
				
				if ( $in_comment_single ) {
					if ( $char === "\n" || $char === "\r" ) {
						$in_comment_single = false;
					}
					continue;
				}
				
				// Handle strings
				if ( ! $in_string && ( "'" === $char || '"' === $char || '`' === $char ) ) {
					$in_string = true;
					$string_char = $char;
					$current_query .= $char;
					continue;
				}
				
				if ( $in_string ) {
					$escape_count = 0;
					for ( $j = $i - 1; $j >= 0 && $buffer[ $j ] === '\\'; $j-- ) {
						$escape_count++;
					}
					$is_escaped = ( $escape_count % 2 === 1 );
					
					if ( $char === $string_char && ! $is_escaped ) {
						$in_string = false;
						$string_char = '';
					}
					$current_query .= $char;
					continue;
				}
				
				$current_query .= $char;
				
				if ( ';' === $char ) {
					$query = trim( $current_query );
					if ( ! empty( $query ) && '--' !== substr( $query, 0, 2 ) ) {
						$queries[] = $query;
					}
					$current_query = '';
				}
			}
		}
		
		// Add last query if exists (might not have semicolon)
		if ( ! empty( trim( $current_query ) ) ) {
			$query = trim( $current_query );
			if ( ! empty( $query ) && '--' !== substr( $query, 0, 2 ) ) {
				$queries[] = $query;
			}
		}
		
		return array_filter( $queries );
	}
	
	/**
	 * Restore plugins from zip file
	 *
	 * Downloads and extracts plugins from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_plugins( $source_url, $token ) {
		return $this->restore_zip_file( $source_url, $token, 'plugins', WP_PLUGIN_DIR );
	}
	
	/**
	 * Restore themes from zip file
	 *
	 * Downloads and extracts themes from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_themes( $source_url, $token ) {
		$themes_dir = trailingslashit( WP_CONTENT_DIR ) . 'themes';
		return $this->restore_zip_file( $source_url, $token, 'themes', $themes_dir );
	}
	
	/**
	 * Restore uploads from zip file
	 *
	 * Downloads and extracts uploads from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_uploads( $source_url, $token ) {
		$upload_dir = wp_upload_dir();
		if ( $upload_dir['error'] ) {
			return false;
		}
		
		$uploads_dir = $upload_dir['basedir'];
		return $this->restore_zip_file( $source_url, $token, 'uploads', $uploads_dir );
	}
	
	/**
	 * Restore files from zip
	 *
	 * Downloads and extracts a zip file to destination directory
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @param string $file_type File type (plugins, themes, uploads)
	 * @param string $destination_dir Destination directory
	 * @return bool True on success, false on failure
	 */
	private function restore_zip_file( $source_url, $token, $file_type, $destination_dir ) {
		// Download zip file
		$result = $this->download_from_source( $source_url, $token, $file_type );
		
		if ( false === $result ) {
			return false;
		}
		
		$zip_path = $result['path'];
		
		// Check if zip file exists
		if ( ! file_exists( $zip_path ) || ! is_readable( $zip_path ) ) {
			return false;
		}
		
		// Initialize WP_Filesystem
		global $wp_filesystem;
		
		if ( empty( $wp_filesystem ) ) {
			require_once ABSPATH . 'wp-admin/includes/file.php';
			WP_Filesystem();
		}
		
		// Check if ZipArchive is available
		if ( ! class_exists( 'ZipArchive' ) ) {
			@unlink( $zip_path );
			return false;
		}
		
		// Open zip file
		$zip = new \ZipArchive();
		$result = $zip->open( $zip_path );
		
		if ( true !== $result ) {
			@unlink( $zip_path );
			return false;
		}
		
		// Ensure destination directory exists
		if ( ! is_dir( $destination_dir ) ) {
			wp_mkdir_p( $destination_dir );
		}
		
		// Extract zip file
		$extracted = $zip->extractTo( $destination_dir );
		
		// Close zip
		$zip->close();
		
		// Delete zip file after extraction
		@unlink( $zip_path );
		
		return $extracted;
	}
	
	/**
	 * Recursive search and replace
	 *
	 * Handles strings, arrays, objects, and serialized data safely
	 *
	 * @param mixed  $data Data to process
	 * @param string $search String to search for
	 * @param string $replace String to replace with
	 * @return mixed Processed data
	 */
	public function recursive_search_replace( $data, $search, $replace ) {
		// Handle null
		if ( null === $data ) {
			return $data;
		}
		
		// Handle serialized data
		if ( is_string( $data ) && is_serialized( $data ) ) {
			// Unserialize
			$unserialized = @unserialize( $data );
			
			// If unserialize failed, treat as regular string
			if ( false === $unserialized && $data !== serialize( false ) ) {
				// Not actually serialized or unserialize failed, do simple replace
				return str_replace( $search, $replace, $data );
			}
			
			// Recursively process unserialized data
			$processed = $this->recursive_search_replace( $unserialized, $search, $replace );
			
			// Re-serialize
			return serialize( $processed );
		}
		
		// Handle strings
		if ( is_string( $data ) ) {
			return str_replace( $search, $replace, $data );
		}
		
		// Handle arrays
		if ( is_array( $data ) ) {
			$result = array();
			foreach ( $data as $key => $value ) {
				// Process key if it's a string
				$new_key = is_string( $key ) ? str_replace( $search, $replace, $key ) : $key;
				
				// Process value recursively
				$result[ $new_key ] = $this->recursive_search_replace( $value, $search, $replace );
			}
			return $result;
		}
		
		// Handle objects
		if ( is_object( $data ) ) {
			// For stdClass objects
			if ( $data instanceof \stdClass ) {
				$result = new \stdClass();
				foreach ( $data as $key => $value ) {
					$new_key = is_string( $key ) ? str_replace( $search, $replace, $key ) : $key;
					$result->$new_key = $this->recursive_search_replace( $value, $search, $replace );
				}
				return $result;
			}
			
			// For other objects, try to serialize/unserialize approach
			// This is safer than trying to modify object properties directly
			$serialized = serialize( $data );
			$unserialized = @unserialize( $serialized );
			
			if ( false !== $unserialized ) {
				$processed = $this->recursive_search_replace( $unserialized, $search, $replace );
				return unserialize( serialize( $processed ) );
			}
			
			// If serialization fails, return as-is
			return $data;
		}
		
		// For other types (int, float, bool), return as-is
		return $data;
	}
	
	/**
	 * Run search and replace across entire database
	 *
	 * Replaces old URL with new URL in all tables and columns
	 *
	 * @param string $old_url Old URL to replace
	 * @param string $new_url New URL to replace with
	 * @return bool True on success, false on failure
	 */
	public function run_search_replace( $old_url, $new_url ) {
		global $wpdb;
		
		if ( empty( $old_url ) || empty( $new_url ) ) {
			return false;
		}
		
		// Normalize URLs (remove trailing slashes for comparison)
		$old_url = untrailingslashit( $old_url );
		$new_url = untrailingslashit( $new_url );
		
		// If URLs are the same, no need to replace
		if ( $old_url === $new_url ) {
			return true;
		}
		
		// Also handle URLs with trailing slashes
		$old_url_variants = array(
			$old_url,
			trailingslashit( $old_url ),
			$old_url . '/',
		);
		
		$new_url_variants = array(
			$new_url,
			trailingslashit( $new_url ),
			$new_url . '/',
		);
		
		// Get all tables
		$tables = $wpdb->get_results( 'SHOW TABLES', ARRAY_N );
		
		if ( empty( $tables ) ) {
			return false;
		}
		
		// Process each table
		foreach ( $tables as $table ) {
			$table_name = $table[0];
			$table_name_clean = str_replace( '`', '', $table_name );
			
			// Skip if table doesn't exist
			if ( ! $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table_name_clean ) ) ) {
				continue;
			}
			
			// Get table columns
			$columns = $wpdb->get_col( "SHOW COLUMNS FROM `{$table_name_clean}`" );
			
			if ( empty( $columns ) ) {
				continue;
			}
			
			// Get primary key column (if exists)
			$primary_key = null;
			$keys = $wpdb->get_results( "SHOW KEYS FROM `{$table_name_clean}` WHERE Key_name = 'PRIMARY'", ARRAY_A );
			if ( ! empty( $keys ) && isset( $keys[0]['Column_name'] ) ) {
				$primary_key = $keys[0]['Column_name'];
			}
			
			// Build column info cache
			$column_info_cache = array();
			foreach ( $columns as $col ) {
				$col_info = $wpdb->get_row( $wpdb->prepare( "SHOW COLUMNS FROM `{$table_name_clean}` WHERE Field = %s", $col ), ARRAY_A );
				if ( $col_info ) {
					$column_info_cache[ $col ] = $col_info;
				}
			}
			
			// Process data in chunks to avoid memory issues
			$chunk_size = 100;
			$offset = 0;
			
			while ( true ) {
				// Get chunk of data
				$rows = $wpdb->get_results(
					$wpdb->prepare(
						"SELECT * FROM `{$table_name_clean}` LIMIT %d OFFSET %d",
						$chunk_size,
						$offset
					),
					ARRAY_A
				);
				
				if ( empty( $rows ) ) {
					break;
				}
				
				// Process each row
				foreach ( $rows as $row ) {
					// Get row identifier
					$row_identifier = null;
					$row_identifier_column = null;
					
					if ( $primary_key && isset( $row[ $primary_key ] ) ) {
						$row_identifier = $row[ $primary_key ];
						$row_identifier_column = $primary_key;
					} else {
						// Use first column as identifier
						$first_column = reset( $columns );
						if ( isset( $row[ $first_column ] ) ) {
							$row_identifier = $row[ $first_column ];
							$row_identifier_column = $first_column;
						}
					}
					
					if ( null === $row_identifier || null === $row_identifier_column ) {
						continue;
					}
					
					// Process each column in this row
					foreach ( $columns as $column ) {
						// Skip if column info not found
						if ( ! isset( $column_info_cache[ $column ] ) ) {
							continue;
						}
						
						$column_info = $column_info_cache[ $column ];
						
						// Skip if column is primary key or auto-increment
						if ( 'PRI' === $column_info['Key'] || 'auto_increment' === $column_info['Extra'] ) {
							continue;
						}
						
						// Skip numeric-only columns (INT, BIGINT, FLOAT, etc.)
						$column_type = strtolower( $column_info['Type'] );
						if ( preg_match( '/^(tinyint|smallint|mediumint|int|bigint|float|double|decimal|numeric)/', $column_type ) ) {
							continue;
						}
						
						// Get current value
						$current_value = isset( $row[ $column ] ) ? $row[ $column ] : null;
						
						// Skip if value is null or empty
						if ( null === $current_value || '' === $current_value ) {
							continue;
						}
						
						// Process value with recursive search replace
						$new_value = $this->recursive_search_replace( $current_value, $old_url, $new_url );
						
						// Also handle variants
						foreach ( $old_url_variants as $index => $old_variant ) {
							if ( $old_variant !== $old_url ) {
								$new_value = $this->recursive_search_replace( $new_value, $old_variant, $new_url_variants[ $index ] );
							}
						}
						
						// Check if value changed
						if ( $current_value !== $new_value ) {
							// Determine format for update
							$format = '%s';
							if ( preg_match( '/^(tinyint|smallint|mediumint|int|bigint)/', $column_type ) ) {
								$format = '%d';
							} elseif ( preg_match( '/^(float|double|decimal|numeric)/', $column_type ) ) {
								$format = '%f';
							}
							
							// Serialize if needed (for complex data types)
							if ( is_array( $new_value ) || is_object( $new_value ) ) {
								$new_value = serialize( $new_value );
							}
							
							// Update database
							$wpdb->update(
								$table_name_clean,
								array( $column => $new_value ),
								array( $row_identifier_column => $row_identifier ),
								array( $format ),
								array( '%s' )
							);
						}
					}
				}
				
				$offset += $chunk_size;
				
				// Check if we've processed all rows
				if ( count( $rows ) < $chunk_size ) {
					break;
				}
				
				// Free memory
				unset( $rows );
			}
		}
		
		return true;
	}
	
	/**
	 * Run search and replace with batch processing
	 *
	 * Processes database in small batches to avoid timeout.
	 * Returns status for next batch or completion.
	 *
	 * @param string $old_url Old URL to replace
	 * @param string $new_url New URL to replace with
	 * @param string $table_name Optional: specific table to process
	 * @param int    $offset Optional: offset for chunk processing
	 * @return array Status array with 'completed', 'next_table', 'next_offset', 'progress'
	 */
	public function run_search_replace_batch( $old_url, $new_url, $table_name = null, $offset = 0 ) {
		global $wpdb;
		
		if ( empty( $old_url ) || empty( $new_url ) ) {
			return array( 'error' => 'URLs required' );
		}
		
		// Normalize URLs
		$old_url = untrailingslashit( $old_url );
		$new_url = untrailingslashit( $new_url );
		
		if ( $old_url === $new_url ) {
			return array( 'completed' => true );
		}
		
		// Also handle URLs with trailing slashes
		$old_url_variants = array(
			$old_url,
			trailingslashit( $old_url ),
			$old_url . '/',
		);
		
		$new_url_variants = array(
			$new_url,
			trailingslashit( $new_url ),
			$new_url . '/',
		);
		
		// Get all tables
		$tables = $wpdb->get_results( 'SHOW TABLES', ARRAY_N );
		
		if ( empty( $tables ) ) {
			return array( 'error' => 'No tables found' );
		}
		
		// Find starting point
		$start_index = 0;
		if ( $table_name ) {
			foreach ( $tables as $index => $table ) {
				$table_name_clean = str_replace( '`', '', $table[0] );
				if ( $table_name_clean === $table_name ) {
					$start_index = $index;
					break;
				}
			}
		}
		
		// Process one table at a time (or continue with current table)
		$chunk_size = 50; // Smaller chunks for batch processing
		$max_execution_time = 25; // 25 seconds per batch (leave buffer for server overhead)
		$start_time = time();
		
		for ( $i = $start_index; $i < count( $tables ); $i++ ) {
			$table = $tables[ $i ];
			$table_name_clean = str_replace( '`', '', $table[0] );
			
			// Check execution time
			if ( ( time() - $start_time ) > $max_execution_time ) {
				return array(
					'completed'   => false,
					'next_table'  => $table_name_clean,
					'next_offset' => $offset,
					'progress'    => sprintf(
						/* translators: %1$d: Current table number, %2$d: Total tables, %3$s: Table name */
						__( 'Processing table %1$d of %2$d: %3$s', 'wp-site-bridge-migration' ),
						$i + 1,
						count( $tables ),
						$table_name_clean
					),
				);
			}
			
			// Process this table
			$result = $this->process_table_search_replace(
				$table_name_clean,
				$old_url,
				$new_url,
				$old_url_variants,
				$new_url_variants,
				$offset,
				$chunk_size,
				$max_execution_time - ( time() - $start_time )
			);
			
			if ( isset( $result['error'] ) ) {
				return $result;
			}
			
			// If table not completed, return for next batch
			if ( ! $result['completed'] ) {
				return array(
					'completed'   => false,
					'next_table'  => $table_name_clean,
					'next_offset' => $result['next_offset'],
					'progress'    => sprintf(
						/* translators: %1$d: Current table number, %2$d: Total tables, %3$s: Table name, %4$d: Start row, %5$d: End row */
						__( 'Processing table %1$d of %2$d: %3$s (Rows %4$d-%5$d)', 'wp-site-bridge-migration' ),
						$i + 1,
						count( $tables ),
						$table_name_clean,
						$offset + 1,
						$result['next_offset']
					),
				);
			}
			
			// Table completed, reset offset for next table
			$offset = 0;
		}
		
		// All tables completed
		return array( 'completed' => true );
	}
	
	/**
	 * Process one table for search and replace
	 *
	 * @param string $table_name Table name
	 * @param string $old_url Old URL
	 * @param string $new_url New URL
	 * @param array  $old_url_variants Array of old URL variants
	 * @param array  $new_url_variants Array of new URL variants
	 * @param int    $offset Starting offset
	 * @param int    $chunk_size Chunk size
	 * @param int    $time_remaining Remaining execution time in seconds
	 * @return array Status array
	 */
	private function process_table_search_replace( $table_name, $old_url, $new_url, $old_url_variants, $new_url_variants, $offset, $chunk_size, $time_remaining ) {
		global $wpdb;
		
		// Skip if table doesn't exist
		if ( ! $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table_name ) ) ) {
			return array( 'completed' => true );
		}
		
		// Get columns
		$columns = $wpdb->get_col( "SHOW COLUMNS FROM `{$table_name}`" );
		if ( empty( $columns ) ) {
			return array( 'completed' => true );
		}
		
		// Get primary key
		$primary_key = null;
		$keys = $wpdb->get_results( "SHOW KEYS FROM `{$table_name}` WHERE Key_name = 'PRIMARY'", ARRAY_A );
		if ( ! empty( $keys ) && isset( $keys[0]['Column_name'] ) ) {
			$primary_key = $keys[0]['Column_name'];
		}
		
		// Build column info cache (only once per table)
		static $column_cache = array();
		$cache_key = $table_name;
		
		if ( ! isset( $column_cache[ $cache_key ] ) ) {
			$column_info_cache = array();
			foreach ( $columns as $col ) {
				$col_info = $wpdb->get_row( $wpdb->prepare( "SHOW COLUMNS FROM `{$table_name}` WHERE Field = %s", $col ), ARRAY_A );
				if ( $col_info ) {
					$column_info_cache[ $col ] = $col_info;
				}
			}
			$column_cache[ $cache_key ] = $column_info_cache;
		} else {
			$column_info_cache = $column_cache[ $cache_key ];
		}
		
		$batch_start_time = time();
		
		// Process chunks until time runs out or table is complete
		while ( ( time() - $batch_start_time ) < $time_remaining ) {
			// Get chunk of rows using LIMIT and OFFSET
			// CRITICAL: Use exact LIMIT and OFFSET to avoid duplicates or skips
			$rows = $wpdb->get_results(
				$wpdb->prepare(
					"SELECT * FROM `{$table_name}` LIMIT %d OFFSET %d",
					$chunk_size,
					$offset
				),
				ARRAY_A
			);
			
			if ( empty( $rows ) ) {
				// No more rows, table is complete
				return array( 'completed' => true );
			}
			
			// Process each row in this chunk
			foreach ( $rows as $row ) {
				// Get row identifier
				$row_identifier = null;
				$row_identifier_column = null;
				
				if ( $primary_key && isset( $row[ $primary_key ] ) ) {
					$row_identifier = $row[ $primary_key ];
					$row_identifier_column = $primary_key;
				} else {
					// Use first column as identifier
					$first_column = reset( $columns );
					if ( isset( $row[ $first_column ] ) ) {
						$row_identifier = $row[ $first_column ];
						$row_identifier_column = $first_column;
					}
				}
				
				if ( null === $row_identifier || null === $row_identifier_column ) {
					continue;
				}
				
				// Process each column in this row
				foreach ( $columns as $column ) {
					// Skip if column info not found
					if ( ! isset( $column_info_cache[ $column ] ) ) {
						continue;
					}
					
					$column_info = $column_info_cache[ $column ];
					
					// Skip if column is primary key or auto-increment
					if ( 'PRI' === $column_info['Key'] || 'auto_increment' === $column_info['Extra'] ) {
						continue;
					}
					
					// Skip numeric-only columns
					$column_type = strtolower( $column_info['Type'] );
					if ( preg_match( '/^(tinyint|smallint|mediumint|int|bigint|float|double|decimal|numeric)/', $column_type ) ) {
						continue;
					}
					
					// Get current value
					$current_value = isset( $row[ $column ] ) ? $row[ $column ] : null;
					
					// Skip if value is null or empty
					if ( null === $current_value || '' === $current_value ) {
						continue;
					}
					
					// Process value with recursive search replace
					$new_value = $this->recursive_search_replace( $current_value, $old_url, $new_url );
					
					// Also handle variants
					foreach ( $old_url_variants as $index => $old_variant ) {
						if ( $old_variant !== $old_url ) {
							$new_value = $this->recursive_search_replace( $new_value, $old_variant, $new_url_variants[ $index ] );
						}
					}
					
					// Check if value changed
					if ( $current_value !== $new_value ) {
						// Determine format for update
						$format = '%s';
						if ( preg_match( '/^(tinyint|smallint|mediumint|int|bigint)/', $column_type ) ) {
							$format = '%d';
						} elseif ( preg_match( '/^(float|double|decimal|numeric)/', $column_type ) ) {
							$format = '%f';
						}
						
						// Serialize if needed (for complex data types)
						if ( is_array( $new_value ) || is_object( $new_value ) ) {
							$new_value = serialize( $new_value );
						}
						
						// Update database
						$wpdb->update(
							$table_name,
							array( $column => $new_value ),
							array( $row_identifier_column => $row_identifier ),
							array( $format ),
							array( '%s' )
						);
					}
				}
			}
			
			// Move to next chunk
			$offset += $chunk_size;
			
			// Check if we've processed all rows
			if ( count( $rows ) < $chunk_size ) {
				// Last chunk was smaller, table is complete
				return array( 'completed' => true );
			}
			
			// Check time limit
			if ( ( time() - $batch_start_time ) >= $time_remaining ) {
				// Time's up, return for next batch
				return array(
					'completed'   => false,
					'next_offset' => $offset,
				);
			}
		}
		
		// Time ran out, return for next batch
		return array(
			'completed'   => false,
			'next_offset' => $offset,
		);
	}
	
	/**
	 * Cleanup temporary files
	 *
	 * Deletes the wpsbm_temp directory and all its contents
	 *
	 * @return bool True on success, false on failure
	 */
	public function cleanup_temp_files() {
		$temp_dir = $this->get_temp_dir();
		
		if ( ! $temp_dir || ! is_dir( $temp_dir ) ) {
			// Directory doesn't exist, consider it cleaned
			return true;
		}
		
		// Use WP_Filesystem for safe deletion
		global $wp_filesystem;
		
		// Initialize filesystem if not already done
		if ( empty( $wp_filesystem ) ) {
			require_once ABSPATH . '/wp-admin/includes/file.php';
			WP_Filesystem();
		}
		
		// Delete directory recursively
		if ( $wp_filesystem && $wp_filesystem->exists( $temp_dir ) ) {
			$deleted = $wp_filesystem->rmdir( $temp_dir, true );
			
			if ( $deleted ) {
				return true;
			}
		}
		
		// Fallback: Use PHP's native functions if WP_Filesystem failed
		$files = new \RecursiveIteratorIterator(
			new \RecursiveDirectoryIterator( $temp_dir, \RecursiveDirectoryIterator::SKIP_DOTS ),
			\RecursiveIteratorIterator::CHILD_FIRST
		);
		
		foreach ( $files as $fileinfo ) {
			$todo = ( $fileinfo->isDir() ? 'rmdir' : 'unlink' );
			@$todo( $fileinfo->getRealPath() );
		}
		
		// Try to remove the directory itself
		@rmdir( $temp_dir );
		
		// Check if directory still exists
		if ( is_dir( $temp_dir ) ) {
			return false;
		}
		
		return true;
	}
}


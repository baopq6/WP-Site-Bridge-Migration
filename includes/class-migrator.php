<?php
/**
 * Migrator class
 *
 * @package WPSiteBridge
 */

namespace WPSiteBridge;

// Exit if accessed directly
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Migrator class
 */
class Migrator {
	
	/**
	 * Plugin instance
	 *
	 * @var Migrator
	 */
	private static $instance = null;
	
	/**
	 * Get plugin instance
	 *
	 * @return Migrator
	 */
	public static function get_instance() {
		if ( null === self::$instance ) {
			self::$instance = new self();
		}
		return self::$instance;
	}
	
	/**
	 * Constructor
	 */
	private function __construct() {
		// Migration logic will be implemented in Phase 3, 4, and 5
	}
	
	/**
	 * Get or create temporary directory
	 *
	 * Creates wp-content/uploads/wpsbm_temp/ if it doesn't exist
	 * Adds .htaccess for protection
	 *
	 * @return string|false Path to temp directory, or false on failure
	 */
	public function get_temp_dir() {
		$upload_dir = wp_upload_dir();
		
		if ( $upload_dir['error'] ) {
			return false;
		}
		
		$temp_dir = trailingslashit( $upload_dir['basedir'] ) . 'wpsbm_temp';
		
		// Create directory if it doesn't exist
		if ( ! file_exists( $temp_dir ) ) {
			wp_mkdir_p( $temp_dir );
		}
		
		// Check if directory was created successfully
		if ( ! is_dir( $temp_dir ) || ! is_writable( $temp_dir ) ) {
			return false;
		}
		
		// Add .htaccess for protection
		$htaccess_file = trailingslashit( $temp_dir ) . '.htaccess';
		if ( ! file_exists( $htaccess_file ) ) {
			file_put_contents( $htaccess_file, "deny from all\n" );
		}
		
		// Add index.php to prevent directory listing
		$index_file = trailingslashit( $temp_dir ) . 'index.php';
		if ( ! file_exists( $index_file ) ) {
			file_put_contents( $index_file, "<?php\n// Silence is golden.\n" );
		}
		
		return $temp_dir;
	}
	
	/**
	 * Export database to SQL file
	 *
	 * Exports all tables with structure and data
	 * Uses chunking to avoid memory exhaustion
	 *
	 * @return array|false Array with 'file' and 'size' keys, or false on failure
	 */
	public function export_database() {
		global $wpdb;
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		$sql_file = trailingslashit( $temp_dir ) . 'database.sql';
		
		// Open file for writing
		$handle = fopen( $sql_file, 'w' );
		if ( false === $handle ) {
			return false;
		}
		
		// Write SQL header
		fwrite( $handle, "-- WordPress Database Backup\n" );
		fwrite( $handle, "-- Generated by WP Site Bridge Migration\n" );
		fwrite( $handle, "-- Date: " . current_time( 'mysql' ) . "\n\n" );
		fwrite( $handle, "SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\n" );
		fwrite( $handle, "SET time_zone = \"+00:00\";\n\n" );
		
		// Get all tables
		$tables = $wpdb->get_results( 'SHOW TABLES', ARRAY_N );
		
		if ( empty( $tables ) ) {
			fclose( $handle );
			return false;
		}
		
		// Process each table
		foreach ( $tables as $table ) {
			$table_name = $table[0];
			
			// Sanitize table name (remove any potential backticks first, then add our own)
			$table_name_clean = str_replace( '`', '', $table_name );
			
			// Skip if table doesn't exist
			if ( ! $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table_name_clean ) ) ) {
				continue;
			}
			
			// Write table comment
			fwrite( $handle, "\n--\n" );
			fwrite( $handle, "-- Table structure for table `{$table_name_clean}`\n" );
			fwrite( $handle, "--\n\n" );
			
			// Get table structure
			$create_table = $wpdb->get_row( "SHOW CREATE TABLE `{$table_name_clean}`", ARRAY_A );
			
			if ( isset( $create_table['Create Table'] ) ) {
				// Write DROP TABLE and CREATE TABLE
				fwrite( $handle, "DROP TABLE IF EXISTS `{$table_name_clean}`;\n" );
				fwrite( $handle, $create_table['Create Table'] . ";\n\n" );
			}
			
			// Get row count
			$row_count = $wpdb->get_var( "SELECT COUNT(*) FROM `{$table_name_clean}`" );
			
			if ( 0 === (int) $row_count ) {
				// Empty table, skip data
				continue;
			}
			
			// Write data comment
			fwrite( $handle, "--\n" );
			fwrite( $handle, "-- Dumping data for table `{$table_name_clean}`\n" );
			fwrite( $handle, "--\n\n" );
			
			// Get table columns
			$columns = $wpdb->get_col( "SHOW COLUMNS FROM `{$table_name_clean}`" );
			
			if ( empty( $columns ) ) {
				continue;
			}
			
			// Process data in chunks (1000 rows at a time)
			$chunk_size = 1000;
			$offset = 0;
			
			while ( true ) {
				// Get chunk of data
				$rows = $wpdb->get_results(
					$wpdb->prepare(
						"SELECT * FROM `{$table_name_clean}` LIMIT %d OFFSET %d",
						$chunk_size,
						$offset
					),
					ARRAY_A
				);
				
				if ( empty( $rows ) ) {
					break;
				}
				
				// Write INSERT statements
				foreach ( $rows as $row ) {
					// Build column names
					$column_names = '`' . implode( '`, `', $columns ) . '`';
					
					// Build values
					$values = array();
					foreach ( $columns as $column ) {
						$value = isset( $row[ $column ] ) ? $row[ $column ] : null;
						
						if ( null === $value ) {
							$values[] = 'NULL';
						} else {
							// Escape value properly
							// Use addslashes for basic escaping, then wrap in quotes
							$escaped = addslashes( $value );
							// Replace newlines and carriage returns
							$escaped = str_replace( array( "\r", "\n" ), array( '\\r', '\\n' ), $escaped );
							$values[] = "'" . $escaped . "'";
						}
					}
					
					$values_string = implode( ', ', $values );
					
					// Write INSERT statement
					fwrite( $handle, "INSERT INTO `{$table_name_clean}` ({$column_names}) VALUES ({$values_string});\n" );
				}
				
				$offset += $chunk_size;
				
				// Check if we've processed all rows
				if ( count( $rows ) < $chunk_size ) {
					break;
				}
				
				// Free memory
				unset( $rows );
			}
			
			fwrite( $handle, "\n" );
		}
		
		// Close file
		fclose( $handle );
		
		// Check if file was created successfully
		if ( ! file_exists( $sql_file ) ) {
			return false;
		}
		
		// Get file size
		$file_size = filesize( $sql_file );
		
		return array(
			'file' => 'database.sql',
			'path' => $sql_file,
			'size' => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Zip a directory
	 *
	 * Creates a zip archive of a directory with exclusions
	 *
	 * @param string $source_dir Source directory to zip
	 * @param string $zip_name Name of the zip file (without path)
	 * @return array|false Array with 'file', 'path', 'size', 'size_formatted' or false on failure
	 */
	public function zip_directory( $source_dir, $zip_name ) {
		// Check if ZipArchive is available
		if ( ! class_exists( 'ZipArchive' ) ) {
			return false;
		}
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		// Check if source directory exists
		if ( ! is_dir( $source_dir ) ) {
			return false;
		}
		
		// Full path to zip file
		$zip_path = trailingslashit( $temp_dir ) . $zip_name;
		
		// Remove existing zip if it exists
		if ( file_exists( $zip_path ) ) {
			@unlink( $zip_path );
		}
		
		// Create new zip archive
		$zip = new \ZipArchive();
		$result = $zip->open( $zip_path, \ZipArchive::CREATE | \ZipArchive::OVERWRITE );
		
		if ( true !== $result ) {
			return false;
		}
		
		// Define exclusions
		$exclusions = array(
			'node_modules',
			'.git',
			'cache',
			'wpsbm_temp',
			'error_log',
			'.DS_Store',
			'Thumbs.db',
		);
		
		// Recursively add files to zip
		$this->add_directory_to_zip( $zip, $source_dir, $source_dir, $exclusions );
		
		// Close zip
		$zip->close();
		
		// Check if file was created
		if ( ! file_exists( $zip_path ) ) {
			return false;
		}
		
		// Get file size
		$file_size = filesize( $zip_path );
		
		return array(
			'file'          => $zip_name,
			'path'          => $zip_path,
			'size'          => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Recursively add directory to zip
	 *
	 * @param ZipArchive $zip ZipArchive instance
	 * @param string $dir Directory to add
	 * @param string $base_dir Base directory for relative paths
	 * @param array $exclusions Array of excluded directory/file names
	 */
	private function add_directory_to_zip( $zip, $dir, $base_dir, $exclusions ) {
		$files = scandir( $dir );
		
		foreach ( $files as $file ) {
			if ( '.' === $file || '..' === $file ) {
				continue;
			}
			
			$file_path = trailingslashit( $dir ) . $file;
			$relative_path = str_replace( trailingslashit( $base_dir ), '', $file_path );
			
			// Check if file/directory should be excluded
			if ( $this->should_exclude( $file, $file_path, $exclusions ) ) {
				continue;
			}
			
			if ( is_dir( $file_path ) ) {
				// Recursively add directory
				$this->add_directory_to_zip( $zip, $file_path, $base_dir, $exclusions );
			} else {
				// Add file to zip
				$zip->addFile( $file_path, $relative_path );
			}
		}
	}
	
	/**
	 * Check if file/directory should be excluded
	 *
	 * @param string $name File/directory name
	 * @param string $path Full path
	 * @param array $exclusions Array of exclusions
	 * @return bool True if should be excluded
	 */
	private function should_exclude( $name, $path, $exclusions ) {
		// Check exact name match
		if ( in_array( $name, $exclusions, true ) ) {
			return true;
		}
		
		// Check if path contains excluded directory
		foreach ( $exclusions as $exclusion ) {
			if ( false !== strpos( $path, '/' . $exclusion . '/' ) || false !== strpos( $path, '\\' . $exclusion . '\\' ) ) {
				return true;
			}
		}
		
		// Exclude hidden files (starting with .)
		if ( '.' === substr( $name, 0, 1 ) && '.htaccess' !== $name && 'index.php' !== $name ) {
			return true;
		}
		
		return false;
	}
	
	/**
	 * Zip plugins directory
	 *
	 * @return array|false Array with file info or false on failure
	 */
	public function zip_plugins() {
		$plugins_dir = WP_PLUGIN_DIR;
		return $this->zip_directory( $plugins_dir, 'plugins.zip' );
	}
	
	/**
	 * Zip themes directory
	 *
	 * @return array|false Array with file info or false on failure
	 */
	public function zip_themes() {
		$themes_dir = trailingslashit( WP_CONTENT_DIR ) . 'themes';
		return $this->zip_directory( $themes_dir, 'themes.zip' );
	}
	
	/**
	 * Zip uploads directory
	 *
	 * @return array|false Array with file info or false on failure
	 */
	public function zip_uploads() {
		$upload_dir = wp_upload_dir();
		if ( $upload_dir['error'] ) {
			return false;
		}
		
		$uploads_dir = $upload_dir['basedir'];
		
		// Exclude wpsbm_temp from uploads
		$exclusions = array( 'wpsbm_temp' );
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		// Check if ZipArchive is available
		if ( ! class_exists( 'ZipArchive' ) ) {
			return false;
		}
		
		// Check if source directory exists
		if ( ! is_dir( $uploads_dir ) ) {
			return false;
		}
		
		// Full path to zip file
		$zip_path = trailingslashit( $temp_dir ) . 'uploads.zip';
		
		// Remove existing zip if it exists
		if ( file_exists( $zip_path ) ) {
			@unlink( $zip_path );
		}
		
		// Create new zip archive
		$zip = new \ZipArchive();
		$result = $zip->open( $zip_path, \ZipArchive::CREATE | \ZipArchive::OVERWRITE );
		
		if ( true !== $result ) {
			return false;
		}
		
		// Define exclusions (merge with default)
		$all_exclusions = array_merge(
			array(
				'node_modules',
				'.git',
				'cache',
				'error_log',
				'.DS_Store',
				'Thumbs.db',
			),
			$exclusions
		);
		
		// Recursively add files to zip
		$this->add_directory_to_zip( $zip, $uploads_dir, $uploads_dir, $all_exclusions );
		
		// Close zip
		$zip->close();
		
		// Check if file was created
		if ( ! file_exists( $zip_path ) ) {
			return false;
		}
		
		// Get file size
		$file_size = filesize( $zip_path );
		
		return array(
			'file'          => 'uploads.zip',
			'path'          => $zip_path,
			'size'          => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Generate migration key
	 *
	 * Generates a secure random token and creates a migration key
	 * in the format: base64_encode(SITE_URL + '||' + SECRET_TOKEN)
	 *
	 * @return string Migration key
	 */
	public function generate_migration_key() {
		// Generate a secure random token (32 characters)
		$token = $this->generate_secure_token( 32 );
		
		// Save token to wp_options
		update_option( 'wpsbm_secret_token', $token );
		
		// Get site URL
		$site_url = trailingslashit( get_site_url() );
		
		// Construct migration key: base64_encode(SITE_URL + '||' + SECRET_TOKEN)
		$key_data = $site_url . '||' . $token;
		$migration_key = base64_encode( $key_data );
		
		// Also save the full migration key for reference
		update_option( 'wpsbm_migration_key', $migration_key );
		
		return $migration_key;
	}
	
	/**
	 * Generate secure random token
	 *
	 * @param int $length Token length
	 * @return string Random token
	 */
	public function generate_secure_token( $length = 32 ) {
		// Use cryptographically secure random bytes
		if ( function_exists( 'random_bytes' ) ) {
			$bytes = random_bytes( $length );
			return bin2hex( $bytes );
		} elseif ( function_exists( 'openssl_random_pseudo_bytes' ) ) {
			$bytes = openssl_random_pseudo_bytes( $length );
			return bin2hex( $bytes );
		} else {
			// Fallback (less secure but still random)
			$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
			$token = '';
			for ( $i = 0; $i < $length; $i++ ) {
				$token .= $chars[ wp_rand( 0, strlen( $chars ) - 1 ) ];
			}
			return $token;
		}
	}
	
	/**
	 * Verify token
	 *
	 * Check if the received token matches the stored token
	 *
	 * @param string $token Token to verify
	 * @return bool True if token is valid, false otherwise
	 */
	public function verify_token( $token ) {
		if ( empty( $token ) ) {
			return false;
		}
		
		// Get stored token
		$stored_token = get_option( 'wpsbm_secret_token' );
		
		if ( empty( $stored_token ) ) {
			return false;
		}
		
		// Use hash_equals for timing-safe comparison
		return hash_equals( $stored_token, $token );
	}
	
	/**
	 * Parse migration key
	 *
	 * Decodes a migration key and extracts site URL and token
	 *
	 * @param string $migration_key Migration key to parse
	 * @return array|false Array with 'url' and 'token' keys, or false on failure
	 */
	public function parse_migration_key( $migration_key ) {
		if ( empty( $migration_key ) ) {
			return false;
		}
		
		// Decode base64
		$decoded = base64_decode( $migration_key, true );
		
		if ( false === $decoded ) {
			return false;
		}
		
		// Split by delimiter
		$parts = explode( '||', $decoded, 2 );
		
		if ( count( $parts ) !== 2 ) {
			return false;
		}
		
		return array(
			'url'   => sanitize_url( $parts[0] ),
			'token' => sanitize_text_field( $parts[1] ),
		);
	}
	
	/**
	 * Download remote file
	 *
	 * Downloads a file from remote URL and saves it locally
	 *
	 * @param string $url Remote URL to download from
	 * @param string $save_path Local path to save the file
	 * @return array|false Array with 'path' and 'size' on success, false on failure
	 */
	public function download_remote_file( $url, $save_path ) {
		if ( empty( $url ) || empty( $save_path ) ) {
			return false;
		}
		
		// Ensure directory exists
		$save_dir = dirname( $save_path );
		if ( ! file_exists( $save_dir ) ) {
			wp_mkdir_p( $save_dir );
		}
		
		// Check if directory is writable
		if ( ! is_writable( $save_dir ) ) {
			return false;
		}
		
		// Use WordPress download_url function if available
		if ( function_exists( 'download_url' ) ) {
			$temp_file = download_url( $url );
			
			if ( is_wp_error( $temp_file ) ) {
				return false;
			}
			
			// Move temp file to final location
			if ( ! @rename( $temp_file, $save_path ) ) {
				@unlink( $temp_file );
				return false;
			}
			
			// Verify file was created
			if ( ! file_exists( $save_path ) ) {
				return false;
			}
			
			$file_size = filesize( $save_path );
			
			return array(
				'path'          => $save_path,
				'size'          => $file_size,
				'size_formatted' => size_format( $file_size, 2 ),
			);
		}
		
		// Fallback: Use wp_remote_get and write to file
		$response = wp_remote_get(
			$url,
			array(
				'timeout'   => 300, // 5 minutes
				'sslverify' => true,
			)
		);
		
		if ( is_wp_error( $response ) ) {
			return false;
		}
		
		$response_code = wp_remote_retrieve_response_code( $response );
		
		if ( 200 !== $response_code ) {
			return false;
		}
		
		// Get response body
		$body = wp_remote_retrieve_body( $response );
		
		if ( empty( $body ) ) {
			return false;
		}
		
		// Write to file
		$written = file_put_contents( $save_path, $body );
		
		if ( false === $written ) {
			return false;
		}
		
		// Verify file was created
		if ( ! file_exists( $save_path ) ) {
			return false;
		}
		
		$file_size = filesize( $save_path );
		
		return array(
			'path'          => $save_path,
			'size'          => $file_size,
			'size_formatted' => size_format( $file_size, 2 ),
		);
	}
	
	/**
	 * Download file from source site
	 *
	 * Downloads a specific file type from the source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @param string $file_type File type (database, plugins, themes, uploads)
	 * @return array|false Array with file info on success, false on failure
	 */
	public function download_from_source( $source_url, $token, $file_type ) {
		if ( empty( $source_url ) || empty( $token ) || empty( $file_type ) ) {
			return false;
		}
		
		// Validate file type
		if ( ! in_array( $file_type, array( 'database', 'plugins', 'themes', 'uploads' ), true ) ) {
			return false;
		}
		
		// Get temp directory
		$temp_dir = $this->get_temp_dir();
		if ( false === $temp_dir ) {
			return false;
		}
		
		// Map file type to filename
		$file_map = array(
			'database' => 'database.sql',
			'plugins'  => 'plugins.zip',
			'themes'   => 'themes.zip',
			'uploads'  => 'uploads.zip',
		);
		
		$filename = $file_map[ $file_type ];
		$save_path = trailingslashit( $temp_dir ) . $filename;
		
		// Build download URL
		$source_url = trailingslashit( $source_url );
		$download_url = $source_url . 'wp-json/wpsbm/v1/download?file_type=' . urlencode( $file_type ) . '&token=' . urlencode( $token );
		
		// Download file
		$result = $this->download_remote_file( $download_url, $save_path );
		
		if ( false === $result ) {
			return false;
		}
		
		return array(
			'file'          => $filename,
			'path'          => $result['path'],
			'size'          => $result['size'],
			'size_formatted' => $result['size_formatted'],
			'type'          => $file_type,
		);
	}
	
	/**
	 * Restore database from SQL file
	 *
	 * Downloads and imports database from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_database( $source_url, $token ) {
		global $wpdb;
		
		// Download database file
		$result = $this->download_from_source( $source_url, $token, 'database' );
		
		if ( false === $result ) {
			return false;
		}
		
		$sql_file = $result['path'];
		
		// Read SQL file
		if ( ! file_exists( $sql_file ) || ! is_readable( $sql_file ) ) {
			return false;
		}
		
		$sql_content = file_get_contents( $sql_file );
		
		if ( false === $sql_content ) {
			return false;
		}
		
		// Split SQL into individual queries
		$queries = $this->split_sql_queries( $sql_content );
		
		if ( empty( $queries ) ) {
			return false;
		}
		
		// Disable foreign key checks temporarily
		$wpdb->query( 'SET FOREIGN_KEY_CHECKS=0;' );
		
		// Execute each query
		foreach ( $queries as $query ) {
			$query = trim( $query );
			
			// Skip empty queries and comments
			if ( empty( $query ) || '--' === substr( $query, 0, 2 ) ) {
				continue;
			}
			
			// Execute query
			$wpdb->query( $query );
			
			// Check for errors
			if ( ! empty( $wpdb->last_error ) ) {
				// Log error but continue (some queries might fail due to existing tables)
				error_log( 'WPSBM Database Import Error: ' . $wpdb->last_error );
			}
		}
		
		// Re-enable foreign key checks
		$wpdb->query( 'SET FOREIGN_KEY_CHECKS=1;' );
		
		// Clean up SQL file
		@unlink( $sql_file );
		
		return true;
	}
	
	/**
	 * Split SQL content into individual queries
	 *
	 * @param string $sql SQL content
	 * @return array Array of SQL queries
	 */
	private function split_sql_queries( $sql ) {
		// Remove SQL comments
		$sql = preg_replace( '/--.*$/m', '', $sql );
		$sql = preg_replace( '/\/\*.*?\*\//s', '', $sql );
		
		// Split by semicolon, but preserve semicolons inside quotes
		$queries = array();
		$current_query = '';
		$in_string = false;
		$string_char = '';
		
		for ( $i = 0; $i < strlen( $sql ); $i++ ) {
			$char = $sql[ $i ];
			
			if ( ! $in_string && ( "'" === $char || '"' === $char || '`' === $char ) ) {
				$in_string = true;
				$string_char = $char;
			} elseif ( $in_string && $char === $string_char && ( $i === 0 || $sql[ $i - 1 ] !== '\\' ) ) {
				$in_string = false;
				$string_char = '';
			}
			
			$current_query .= $char;
			
			if ( ! $in_string && ';' === $char ) {
				$queries[] = trim( $current_query );
				$current_query = '';
			}
		}
		
		// Add last query if exists
		if ( ! empty( trim( $current_query ) ) ) {
			$queries[] = trim( $current_query );
		}
		
		return array_filter( $queries );
	}
	
	/**
	 * Restore plugins from zip file
	 *
	 * Downloads and extracts plugins from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_plugins( $source_url, $token ) {
		return $this->restore_zip_file( $source_url, $token, 'plugins', WP_PLUGIN_DIR );
	}
	
	/**
	 * Restore themes from zip file
	 *
	 * Downloads and extracts themes from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_themes( $source_url, $token ) {
		$themes_dir = trailingslashit( WP_CONTENT_DIR ) . 'themes';
		return $this->restore_zip_file( $source_url, $token, 'themes', $themes_dir );
	}
	
	/**
	 * Restore uploads from zip file
	 *
	 * Downloads and extracts uploads from source site
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @return bool True on success, false on failure
	 */
	public function restore_uploads( $source_url, $token ) {
		$upload_dir = wp_upload_dir();
		if ( $upload_dir['error'] ) {
			return false;
		}
		
		$uploads_dir = $upload_dir['basedir'];
		return $this->restore_zip_file( $source_url, $token, 'uploads', $uploads_dir );
	}
	
	/**
	 * Restore files from zip
	 *
	 * Downloads and extracts a zip file to destination directory
	 *
	 * @param string $source_url Source site URL
	 * @param string $token Authentication token
	 * @param string $file_type File type (plugins, themes, uploads)
	 * @param string $destination_dir Destination directory
	 * @return bool True on success, false on failure
	 */
	private function restore_zip_file( $source_url, $token, $file_type, $destination_dir ) {
		// Download zip file
		$result = $this->download_from_source( $source_url, $token, $file_type );
		
		if ( false === $result ) {
			return false;
		}
		
		$zip_path = $result['path'];
		
		// Check if zip file exists
		if ( ! file_exists( $zip_path ) || ! is_readable( $zip_path ) ) {
			return false;
		}
		
		// Initialize WP_Filesystem
		global $wp_filesystem;
		
		if ( empty( $wp_filesystem ) ) {
			require_once ABSPATH . 'wp-admin/includes/file.php';
			WP_Filesystem();
		}
		
		// Check if ZipArchive is available
		if ( ! class_exists( 'ZipArchive' ) ) {
			@unlink( $zip_path );
			return false;
		}
		
		// Open zip file
		$zip = new \ZipArchive();
		$result = $zip->open( $zip_path );
		
		if ( true !== $result ) {
			@unlink( $zip_path );
			return false;
		}
		
		// Ensure destination directory exists
		if ( ! is_dir( $destination_dir ) ) {
			wp_mkdir_p( $destination_dir );
		}
		
		// Extract zip file
		$extracted = $zip->extractTo( $destination_dir );
		
		// Close zip
		$zip->close();
		
		// Delete zip file after extraction
		@unlink( $zip_path );
		
		return $extracted;
	}
	
	/**
	 * Recursive search and replace
	 *
	 * Handles strings, arrays, objects, and serialized data safely
	 *
	 * @param mixed  $data Data to process
	 * @param string $search String to search for
	 * @param string $replace String to replace with
	 * @return mixed Processed data
	 */
	public function recursive_search_replace( $data, $search, $replace ) {
		// Handle null
		if ( null === $data ) {
			return $data;
		}
		
		// Handle serialized data
		if ( is_string( $data ) && is_serialized( $data ) ) {
			// Unserialize
			$unserialized = @unserialize( $data );
			
			// If unserialize failed, treat as regular string
			if ( false === $unserialized && $data !== serialize( false ) ) {
				// Not actually serialized or unserialize failed, do simple replace
				return str_replace( $search, $replace, $data );
			}
			
			// Recursively process unserialized data
			$processed = $this->recursive_search_replace( $unserialized, $search, $replace );
			
			// Re-serialize
			return serialize( $processed );
		}
		
		// Handle strings
		if ( is_string( $data ) ) {
			return str_replace( $search, $replace, $data );
		}
		
		// Handle arrays
		if ( is_array( $data ) ) {
			$result = array();
			foreach ( $data as $key => $value ) {
				// Process key if it's a string
				$new_key = is_string( $key ) ? str_replace( $search, $replace, $key ) : $key;
				
				// Process value recursively
				$result[ $new_key ] = $this->recursive_search_replace( $value, $search, $replace );
			}
			return $result;
		}
		
		// Handle objects
		if ( is_object( $data ) ) {
			// For stdClass objects
			if ( $data instanceof \stdClass ) {
				$result = new \stdClass();
				foreach ( $data as $key => $value ) {
					$new_key = is_string( $key ) ? str_replace( $search, $replace, $key ) : $key;
					$result->$new_key = $this->recursive_search_replace( $value, $search, $replace );
				}
				return $result;
			}
			
			// For other objects, try to serialize/unserialize approach
			// This is safer than trying to modify object properties directly
			$serialized = serialize( $data );
			$unserialized = @unserialize( $serialized );
			
			if ( false !== $unserialized ) {
				$processed = $this->recursive_search_replace( $unserialized, $search, $replace );
				return unserialize( serialize( $processed ) );
			}
			
			// If serialization fails, return as-is
			return $data;
		}
		
		// For other types (int, float, bool), return as-is
		return $data;
	}
	
	/**
	 * Run search and replace across entire database
	 *
	 * Replaces old URL with new URL in all tables and columns
	 *
	 * @param string $old_url Old URL to replace
	 * @param string $new_url New URL to replace with
	 * @return bool True on success, false on failure
	 */
	public function run_search_replace( $old_url, $new_url ) {
		global $wpdb;
		
		if ( empty( $old_url ) || empty( $new_url ) ) {
			return false;
		}
		
		// Normalize URLs (remove trailing slashes for comparison)
		$old_url = untrailingslashit( $old_url );
		$new_url = untrailingslashit( $new_url );
		
		// If URLs are the same, no need to replace
		if ( $old_url === $new_url ) {
			return true;
		}
		
		// Also handle URLs with trailing slashes
		$old_url_variants = array(
			$old_url,
			trailingslashit( $old_url ),
			$old_url . '/',
		);
		
		$new_url_variants = array(
			$new_url,
			trailingslashit( $new_url ),
			$new_url . '/',
		);
		
		// Get all tables
		$tables = $wpdb->get_results( 'SHOW TABLES', ARRAY_N );
		
		if ( empty( $tables ) ) {
			return false;
		}
		
		// Process each table
		foreach ( $tables as $table ) {
			$table_name = $table[0];
			$table_name_clean = str_replace( '`', '', $table_name );
			
			// Skip if table doesn't exist
			if ( ! $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table_name_clean ) ) ) {
				continue;
			}
			
			// Get table columns
			$columns = $wpdb->get_col( "SHOW COLUMNS FROM `{$table_name_clean}`" );
			
			if ( empty( $columns ) ) {
				continue;
			}
			
			// Get primary key column (if exists)
			$primary_key = null;
			$keys = $wpdb->get_results( "SHOW KEYS FROM `{$table_name_clean}` WHERE Key_name = 'PRIMARY'", ARRAY_A );
			if ( ! empty( $keys ) && isset( $keys[0]['Column_name'] ) ) {
				$primary_key = $keys[0]['Column_name'];
			}
			
			// Build column info cache
			$column_info_cache = array();
			foreach ( $columns as $col ) {
				$col_info = $wpdb->get_row( $wpdb->prepare( "SHOW COLUMNS FROM `{$table_name_clean}` WHERE Field = %s", $col ), ARRAY_A );
				if ( $col_info ) {
					$column_info_cache[ $col ] = $col_info;
				}
			}
			
			// Process data in chunks to avoid memory issues
			$chunk_size = 100;
			$offset = 0;
			
			while ( true ) {
				// Get chunk of data
				$rows = $wpdb->get_results(
					$wpdb->prepare(
						"SELECT * FROM `{$table_name_clean}` LIMIT %d OFFSET %d",
						$chunk_size,
						$offset
					),
					ARRAY_A
				);
				
				if ( empty( $rows ) ) {
					break;
				}
				
				// Process each row
				foreach ( $rows as $row ) {
					// Get row identifier
					$row_identifier = null;
					$row_identifier_column = null;
					
					if ( $primary_key && isset( $row[ $primary_key ] ) ) {
						$row_identifier = $row[ $primary_key ];
						$row_identifier_column = $primary_key;
					} else {
						// Use first column as identifier
						$first_column = reset( $columns );
						if ( isset( $row[ $first_column ] ) ) {
							$row_identifier = $row[ $first_column ];
							$row_identifier_column = $first_column;
						}
					}
					
					if ( null === $row_identifier || null === $row_identifier_column ) {
						continue;
					}
					
					// Process each column in this row
					foreach ( $columns as $column ) {
						// Skip if column info not found
						if ( ! isset( $column_info_cache[ $column ] ) ) {
							continue;
						}
						
						$column_info = $column_info_cache[ $column ];
						
						// Skip if column is primary key or auto-increment
						if ( 'PRI' === $column_info['Key'] || 'auto_increment' === $column_info['Extra'] ) {
							continue;
						}
						
						// Skip numeric-only columns (INT, BIGINT, FLOAT, etc.)
						$column_type = strtolower( $column_info['Type'] );
						if ( preg_match( '/^(tinyint|smallint|mediumint|int|bigint|float|double|decimal|numeric)/', $column_type ) ) {
							continue;
						}
						
						// Get current value
						$current_value = isset( $row[ $column ] ) ? $row[ $column ] : null;
						
						// Skip if value is null or empty
						if ( null === $current_value || '' === $current_value ) {
							continue;
						}
						
						// Process value with recursive search replace
						$new_value = $this->recursive_search_replace( $current_value, $old_url, $new_url );
						
						// Also handle variants
						foreach ( $old_url_variants as $index => $old_variant ) {
							if ( $old_variant !== $old_url ) {
								$new_value = $this->recursive_search_replace( $new_value, $old_variant, $new_url_variants[ $index ] );
							}
						}
						
						// Check if value changed
						if ( $current_value !== $new_value ) {
							// Determine format for update
							$format = '%s';
							if ( preg_match( '/^(tinyint|smallint|mediumint|int|bigint)/', $column_type ) ) {
								$format = '%d';
							} elseif ( preg_match( '/^(float|double|decimal|numeric)/', $column_type ) ) {
								$format = '%f';
							}
							
							// Serialize if needed (for complex data types)
							if ( is_array( $new_value ) || is_object( $new_value ) ) {
								$new_value = serialize( $new_value );
							}
							
							// Update database
							$wpdb->update(
								$table_name_clean,
								array( $column => $new_value ),
								array( $row_identifier_column => $row_identifier ),
								array( $format ),
								array( '%s' )
							);
						}
					}
				}
				
				$offset += $chunk_size;
				
				// Check if we've processed all rows
				if ( count( $rows ) < $chunk_size ) {
					break;
				}
				
				// Free memory
				unset( $rows );
			}
		}
		
		return true;
	}
	
	/**
	 * Cleanup temporary files
	 *
	 * Deletes the wpsbm_temp directory and all its contents
	 *
	 * @return bool True on success, false on failure
	 */
	public function cleanup_temp_files() {
		$temp_dir = $this->get_temp_dir();
		
		if ( ! $temp_dir || ! is_dir( $temp_dir ) ) {
			// Directory doesn't exist, consider it cleaned
			return true;
		}
		
		// Use WP_Filesystem for safe deletion
		global $wp_filesystem;
		
		// Initialize filesystem if not already done
		if ( empty( $wp_filesystem ) ) {
			require_once ABSPATH . '/wp-admin/includes/file.php';
			WP_Filesystem();
		}
		
		// Delete directory recursively
		if ( $wp_filesystem && $wp_filesystem->exists( $temp_dir ) ) {
			$deleted = $wp_filesystem->rmdir( $temp_dir, true );
			
			if ( $deleted ) {
				return true;
			}
		}
		
		// Fallback: Use PHP's native functions if WP_Filesystem failed
		$files = new \RecursiveIteratorIterator(
			new \RecursiveDirectoryIterator( $temp_dir, \RecursiveDirectoryIterator::SKIP_DOTS ),
			\RecursiveIteratorIterator::CHILD_FIRST
		);
		
		foreach ( $files as $fileinfo ) {
			$todo = ( $fileinfo->isDir() ? 'rmdir' : 'unlink' );
			@$todo( $fileinfo->getRealPath() );
		}
		
		// Try to remove the directory itself
		@rmdir( $temp_dir );
		
		// Check if directory still exists
		if ( is_dir( $temp_dir ) ) {
			return false;
		}
		
		return true;
	}
}

